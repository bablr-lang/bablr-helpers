/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./productions.macro.js#f1d7575719a2690bc530f7c4dd1607fd8a4bdc7d
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import { interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import { interpolateArrayChildren as _interpolateArrayChildren } from "@bablr/agast-helpers/template";
import { interpolateArray as _interpolateArray } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
export function* List({
  value: props,
  ctx
}) {
  const {
    element,
    separator,
    allowHoles = false,
    allowTrailingSeparator = true
  } = ctx.unbox(props);
  let sep, it;
  for (;;) {
    it = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(element, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(element)],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (it || allowTrailingSeparator) {
      sep = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(separator, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [..._interpolateArray(separator), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("separators[]")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    if (!(sep || allowHoles)) break;
  }
}
export function* Any({
  value: matchers,
  ctx
}) {
  for (const matcher of ctx.unbox(matchers)) {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(matcher, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(matcher)],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) break;
  }
}
export function* All({
  value: matchers,
  ctx
}) {
  for (const matcher of ctx.unbox(matchers)) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(matcher, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(matcher)],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
}
export function* Punctuator({
  intrinsicValue
}) {
  if (!intrinsicValue) throw new Error('Intrinsic productions must have value');
  yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(intrinsicValue, _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
      open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
      values: [..._interpolateArray(intrinsicValue)],
      close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {});
}
export const Keyword = Punctuator;
export function* Optional({
  value: matchers,
  ctx
}) {
  const matchers_ = ctx.unbox(matchers);
  if (matchers_.length > 1) {
    throw new Error('Optional only allows one matcher');
  }
  yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
    verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
    arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(matchers_[0], _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
      open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
      values: [..._interpolateArray(matchers_[0])],
      close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
    }, {})
  }, {});
}